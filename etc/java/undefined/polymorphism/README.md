# Polymorphism

하나의 타입에 여러 객체를 대입할 수 있다 ?? -> 하나의 메서드 선언으로 다양한 타입의 인자를 받아서 처리하기 .

같은 조상을 상속하고 있는 자손 클래스들에 한해서, 매개변수를 자손의 타입으로 선언하지 않고 조상의 타입으로 선언하여 코드를 재사용함. -> 자손의 타입에 따라 일일히 오버로딩할 필요가 없음.&#x20;

참조변수의 타입을 힙 영역에 생성한 인스턴스 타입으로 지정하지 않고 참조하려는 인스턴스의 조상 타입으로 지정하는 것.&#x20;

#### instanceof 연산자&#x20;

참조변수(객체)가 참조하는 인스턴스의 타입을 검사해야 할 때&#x20;

```java
if(참조변수 instanceof 객체 타입) {...;}
```

#### casting&#x20;

```
(데이터 타입) 참조변수 
```



### 클래스 다형성&#x20;

```java
Person p = new Person();
 
Singer s = new Singer(); --> Person을 상속함. 
```

* 참조변수 s는 Singer 의 인스턴스 주소값을 갖기 때문에 타입이 Singer 임.&#x20;
* 동시에 참조변수 s는 Object로도 선언할 수 있음. 왜냐 Object 인스턴스도 생성되었기 때문임.
* 마찬가지로 참조변수 s는 Person으로도 선언할 수 있음. 왜냐 Person 인스턴스도 생성되었기 때문임.

s는 타입이 Singer이자, Person 이자, Object임 세 가지 타입 모두 선언가능함. 힙 영역에 생성된 Singer 의 인스턴스를 참조하는 변수타입을 Singer, Person, Object로 선언할 수 있는 것 => 다형성&#x20;

```
Singer s = new Singer();
Person s = new Singer();
Object s = new Singer(); 
```

### 인터페이스 다형성&#x20;





## interface vs. 추상 클래스&#x20;

두 가지 모두 코드의 중복을 제거하여 유지보수성을 높이는 데 목적을 두고 있음. 비슷한것 같은데 가 다를까 ?&#x20;

둘 다 직접 인스턴스를 생성할 수는 없지만, 구현클래스(서브클래스)를 통해서 인스턴스화 가능 => 공통된 특성을 기준으로 메서드를 call하는 등 다형성 확보가능 !

| interface                                                                                                                                               | 추상 클래스                                                                                                                                                |
| ------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| <p>다중상속 가능 </p><ul><li>목적 : 동일한 동작을 약속하기. ( 응답할 수 있는 요청의 집합) (구현을 강제)</li><li>객체의 타입 (난 이런 기능을 할 줄 알아)</li><li>계층은 동등한 수준 &#x26;  다른 구현일 때   </li></ul> | <p>단일 상속 only </p><ul><li>이미 정의된 객체(super class)의 구현을 바탕으로함. </li><li>코드와 내부구조를 공유하는 매커니즘 (상속) </li><li>계층구조  (부모-자식관계)</li><li>인스턴스를 호출할 때</li></ul> |
| <ul><li>약속을 공유하는것이 존재의 의미</li><li>추상 메서드만 가능했으나 디폴트메서도 정의 가능</li><li>필드는 상수(final) 만 가능 </li></ul>                                                      | <ul><li>코드 재사용이 목적이므로, 일부 메서드는 super class에서 직접 구현도 가능함. </li><li>일반적인 필드도 선언가능 </li></ul>                                                            |
| implements                                                                                                                                              | extends                                                                                                                                               |
| <p>구현클래스를 통해 인스턴스화 </p><ul><li>인터페이스명 aa = new 클래스명() ;</li></ul>                                                                                       | <p>sub클래스를 통해 인스턴스화 </p><ul><li>추상클래스명 bb = new 클래스명() ;</li></ul>                                                                                    |

