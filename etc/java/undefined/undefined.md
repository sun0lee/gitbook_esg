---
description: 객체, 인터페이스, 클래스 means..
---

# 객체지향

## 1. Object ; 객체

> **데이터**와 데이터의 **연산**(method,operation)을 묶은 단위&#x20;

* request; 요청은 객체가 연산을 실행하게 하는 유일한 방법
* 연산은 객체 내부 데이터 상태를 변경하는 유일한 방법
* 접근의 제약으로 객체 내부 상태는 캡슐화 (encapsulate) 됨.
* 객체 외부에서는 객체 내부 데이터에 접근할 수 없고, 내부 데이터 타입도 모름.

> 객체는 클래스를 인스턴스로 만듦으로 생성됨. (객체는 클래스의 인스턴스)
>
> * 클래스의 인스턴스화&#x20;
>   * 객체 내부 데이터(instance variable)에 대한 공간 할당하고, 이 데이터들을 연산과 관련 짓는 것.&#x20;



## 2. Interface ; 인터페이스&#x20;

> 객체가 정의하는 연산의 모든 signature(연산이름, 매개변수, return 값)를 일컫는다. 객체가 받아서 처리할 수 있는 연산의 집합.&#x20;

#### Type ; 타입

타입은 특정 인터페이스를 나타낼 때 사용하는 이름. 예를 들어 객체가 "List" 타입을 갖는다 <=> "List" 인터페이스에 정의한 연산을 모두 처리할 수 있다는 것을 의미함.

* 객체가 응답할 수 있는 요청의 집합 => 객체의 타입을 정의&#x20;
* 하나의 객체는 여러 타입을 가질 수 있음.
* 서로 다른 클래스의 객체가 동일한 타입을 가질 수 있음. (구현은 다르지만 인터페이스는 같을 수 있음.)
* 같은 타입의 두 객체는 인터페이스의 일부를 공유함.&#x20;

객체는 인터페이스로 자신을 드러낸다. (외부에서 객체를 알 수 있는 방법) -> 너 뭐하는 애니??

* 외부에서는 인터페이스를 통해서만 처리를 요청할 수 있음.
* 인터페이스는 구현에 대해서는 알려주지 않음.&#x20;
* 서로 다른 객체는 인터페이스에 정의한 요청의 구현방법을 자유롭게 선택할 수 있음.&#x20;

#### Polymorphism ; 다형성&#x20;

* 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있음
* 객체에 요청이 전달되면 요청과 객체에 따라 수행되는 처리 방식이 달라짐. (동일한 요청이라도 처리하는 객체가 다르면 구현을 어떻게 했는가에 따라 다른 결과가 나올 수 있음)

<details>

<summary>dynamic binding ; 동적바인딩</summary>

어떤 요청과 그 요청을 처리할 객체를 프로그램 실행 중, 런타임에 연결 짓는 것. 즉, 요청이 어떻게 구현되어 어떤 결과를 만들어 낼지를 런타임에 결정할 수 있음.&#x20;

프로그램을 작성할 때 객체가 어떤 특정 인터페이스를 갖도록 작성하며, 이 객체는 요청을 처리할 정확한 인터페이스를 가지고 있음.&#x20;

동적 바인딩은 프로그램이 기대하는 객체를 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있게 해줌. 이러한 대체성을 **다형성**이라고 함.&#x20;

</details>

#### 인터페이스의 상속 (SubTyping) => 다형성&#x20;

어떤 객체가 다른 객체 대신 사용될수 있는 경우 지정하는 메커니즘. 인터페이스 상속관계가 있다면, 프로그램에는 슈퍼타입으로 정의하지만 런타임에 서브타입 객체로 대체할 수 있음.&#x20;

concrete class를 정의하고 요청을 보내기보다 추상 클래스의 객체에게 메시지를 보내도록 프로그래밍 함. 이렇게 하면 런타임에 구현 클래스의 인스턴스로 바꿀 수 있음. => 추상클래스를 상속한다는 것은 코드 재사용을 위한 상속이 아니라 추상 클래스가 정의하는 인터페이스를 상속하겠다 의미임. &#x20;



## 3. Class

> 객체의 구현은 class에서 define 한다.
>
> 클래스는 객체의 내부 데이터와 표현 방법을 명세하고, 그 객체가 수행할 연산을 정의함.&#x20;

* 객체는 클래스의 인스턴스화 하여 생성된다.&#x20;
* 객체의  클래스는 그 객체가 어떻게 구현되느냐를 정의함.
* 객체 내부 상태와 그 객체의 연산에 대한 구현방법을 정의. &#x20;

#### 클래스의 상속

이미 정의된 객체의 구현을 바탕으로 함. 코드와 내부구조를 공유하는 메커니즘.&#x20;

* 부모 클래스 구현의 재사용&#x20;
* 동일한 인터페이스를 갖는 객체군을 정의하는 것. => 다형성 !!



## 4. 구현이 아닌 인터페이스에 따라 프로그래밍하기

> * 어떤 객체를 concrete 클래스의 인스턴스로 선언하는 일은 피하기&#x20;
> * 추상 클래스의 인터페이스를 따르는 인스턴스 변수를 정의하기 &#x20;

상속을 적절히 이용하면 모든 클래스는 추상 클래스를 상속하도록 하여 인터페이스를 공유할 수 있게 됨.  모든 서브클래스들은 추상 클래스에 정의한 인터페이스를 처리할 수 있음. 즉, 부모 클래스에 정의된 요청이 서브 클래스에 전달 되어도 서브 클래스가 이를 처리할 수 있음을 의미  => 모든 서브 클래스들은 부모 클래스의 서브타입이 된다.&#x20;

* 추상 클래스를 정의하고 인터페이스 개념으로 객체를 다룰때&#x20;
  * 사용자가 원하는 인터페이스를 그 객체가 만족하는 한 사용자는 그들이 사용하는 특정 객체 타입에 대해 알 필요가 없음&#x20;
  * 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 단지 인터페이스를 정의하는 추상 클래스가 무엇인지만 알면 됨.&#x20;
* 서브 시스템간의 구현 종속성이 없어짐. => 재사용 가능한 객체 지향 개발 원칙 !! **"구현이 아닌 인터페이스에 따라 프로그래밍하기**"
